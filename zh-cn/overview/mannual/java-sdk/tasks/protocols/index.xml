<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/</link><description>Recent content in 通信协议 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview: Dubbo 支持的 RPC 通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/protocol/</guid><description>
&lt;p>Dubbo 作为一款 RPC 框架内置了高效的 RPC 通信协议，帮助解决服务间的编码与通信问题，目前支持的协议包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>triple&lt;/strong>，基于 HTTP/1、HTTP/2 的高性能通信协议，100% 兼容 gRPC，支持 Unary、Streming 等通信模式；&lt;/li>
&lt;li>&lt;strong>dubbo&lt;/strong>，基于 TCP 的高性能私有通信协议，缺点是通用性较差，更适合在 Dubbo SDK 间使用；&lt;/li>
&lt;li>&lt;strong>rest&lt;/strong>，基于 HTTP+JSON 标准的通信协议，用于发布 REST 风格的 HTTP 服务，网关等路由组件兼容性高；&lt;/li>
&lt;li>&lt;strong>多种生态扩展协议&lt;/strong>；&lt;/li>
&lt;/ul>
&lt;h2 id="协议概览">协议概览&lt;/h2>
&lt;p>&lt;strong>开发者该如何确定使用哪一种协议那？&lt;/strong> 以下是我们从使用场景、性能、编程易用性、多语言互通等方面对多个主流协议的对比分析：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>协议&lt;/th>
&lt;th>性能&lt;/th>
&lt;th>网关友好&lt;/th>
&lt;th>Streaming通信模式&lt;/th>
&lt;th>多语言互通&lt;/th>
&lt;th>编程API&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>triple&lt;/td>
&lt;td>aaa&lt;/td>
&lt;td>bbb&lt;/td>
&lt;td>ccc&lt;/td>
&lt;td>ddd&lt;/td>
&lt;td>eee&lt;/td>
&lt;td>fff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dubbo&lt;/td>
&lt;td>aaa&lt;/td>
&lt;td>bbb&lt;/td>
&lt;td>ccc&lt;/td>
&lt;td>ddd&lt;/td>
&lt;td>eee&lt;/td>
&lt;td>fff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rest&lt;/td>
&lt;td>aaa&lt;/td>
&lt;td>bbb&lt;/td>
&lt;td>ccc&lt;/td>
&lt;td>ddd&lt;/td>
&lt;td>eee&lt;/td>
&lt;td>fff&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="alert alert-info" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
考虑到对过往版本的兼容性，当前 Dubbo 各个发行版本均默认使用 &lt;code>dubbo&lt;/code> 通信协议。&lt;strong>但对于新用户而言，我们强烈建议在一开始就明确配置使用 &lt;code>triple&lt;/code> 协议&lt;/strong>，老用户也尽快参考文档 &lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/migration">实现协议的平滑迁移&lt;/a>。
&lt;/div>
&lt;p>以下是几个主要协议的具体开发、配置、运行态信息：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>协议名称&lt;/th>
&lt;th>配置值&lt;/th>
&lt;th>服务定义方式&lt;/th>
&lt;th>默认端口&lt;/th>
&lt;th>传输层协议&lt;/th>
&lt;th>序列化协议&lt;/th>
&lt;th>是否默认&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>triple&lt;/strong>&lt;/td>
&lt;td>tri&lt;/td>
&lt;td>- Java Interface &lt;br/> - Protobuf(IDL)&lt;/td>
&lt;td>50051&lt;/td>
&lt;td>HTTP/1、HTTP/2&lt;/td>
&lt;td>Protobuf Binary、Protobuf JSON&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>dubbo&lt;/strong>&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>- Java Interface&lt;/td>
&lt;td>20880&lt;/td>
&lt;td>TCP&lt;/td>
&lt;td>Hessian、Fastjson2、JSON、JDK、Avro、Kryo 等&lt;/td>
&lt;td>&lt;strong>是&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>rest&lt;/strong>&lt;/td>
&lt;td>rest&lt;/td>
&lt;td>- Java Interface + SpringMVC &lt;br/> - Java Interface + JAX-RS&lt;/td>
&lt;td>8080&lt;/td>
&lt;td>HTTP/1、HTTP/2&lt;/td>
&lt;td>JSON&lt;/td>
&lt;td>否&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>接下来，我们一起看以下几个协议的基本使用方式。&lt;/p>
&lt;h2 id="triple-协议">Triple 协议&lt;/h2>
&lt;h3 id="基本配置">基本配置&lt;/h3>
&lt;p>通过以下配置启用 triple 协议，默认端口为 50051，如果设置 &lt;code>port: -1&lt;/code> 则会随机选取端口（从 50051 自增，直到找到第一个可用端口）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protocol&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">name&lt;/span>: tri
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">port&lt;/span>: &lt;span style="color:#2aa198">50051&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="服务定义方式">服务定义方式&lt;/h3>
&lt;p>使用 triple 协议时，开发者可以使用 &lt;code>Java Interface&lt;/code>、&lt;code>Protobuf(IDL)&lt;/code> 两种方式定义 Dubbo RPC 服务，两种服务定义模式下的协议能力是对等的，仅影响开发者的编程体验，具体选用那种开发模式，取决于使用者的业务背景。&lt;/p>
&lt;h4 id="1-java-interface">1. Java Interface&lt;/h4>
&lt;p>即通过声明一个 Java 接口的方式定义服务，我们在快速开始一节中看到的示例即是这种模式，&lt;strong>适合于没有跨语言诉求的开发团队，具备学习成本低的优势，Dubbo2 老用户可以零成本切换协议&lt;/strong>。&lt;/p>
&lt;p>服务定义范例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种模式下，序列化方式可以选用 Hessian、JSON、Kryo、JDK、自定义扩展等任意编码协议。在使用体验上，可以说与老版本 dubbo 协议没有任何区别，只需要改一个 protocol 配置项即可，因此对于 dubbo 协议迁移到 triple 也会更平滑。&lt;/p>
&lt;p>请通过【进阶学习 - 通信协议】查看 &lt;a href="">java Interface + Triple 协议的具体使用示例&lt;/a>。&lt;/p>
&lt;h4 id="2-protobufidl">2. Protobuf(IDL)&lt;/h4>
&lt;p>使用 Protobuf(IDL) 的方式定义服务，&lt;strong>适合于当前或未来有跨语言诉求的开发团队，同一份 IDL 服务可同时用于 Java/Go/Node.js 等多语言微服务开发，劣势是学习成本较高&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Protobuf" data-lang="Protobuf">&lt;span style="display:flex;">&lt;span>syntax &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;proto3&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">option&lt;/span> java_multiple_files &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">package&lt;/span> org&lt;span style="color:#719e07">.&lt;/span>apache.dubbo.springboot.demo.idl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">message&lt;/span> &lt;span style="color:#268bd2">GreeterRequest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">string&lt;/span> name &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">message&lt;/span> &lt;span style="color:#268bd2">GreeterReply&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">string&lt;/span> &lt;span style="color:#268bd2">message&lt;/span> &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">service&lt;/span> Greeter{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">rpc&lt;/span> greet(GreeterRequest) &lt;span style="color:#719e07">returns&lt;/span> (GreeterReply);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 Dubbo 提供的 protoc 编译插件，将以上 IDL 服务定义预编译为相关 stub 代码，其中就包含 Dubbo 需要的 Interface 接口定义，因此在后续编码上区别并不大，只不过相比于前面的用户自定义 Java Interface 模式，这里由插件自动帮我们生成 Interface 定义。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Generated by dubbo protoc plugin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Greeter&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> org.apache.dubbo.rpc.model.DubboStub {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String JAVA_SERVICE_NAME &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.springboot.demo.idl.Greeter&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String SERVICE_NAME &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.springboot.demo.idl.Greeter&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> org.apache.dubbo.springboot.demo.idl.GreeterReply &lt;span style="color:#268bd2">greet&lt;/span>(org.apache.dubbo.springboot.demo.idl.GreeterRequest request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// more generated codes here...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Protobuf 模式支持序列化方式有 Protobuf Binary、Protobuf JSON 两种模式。最后，请通过【进阶学习 - 通信协议】查看 &lt;a href="">Protobuf (IDL) + Triple 协议的具体使用示例&lt;/a>。&lt;/p>
&lt;h4 id="3-我该使用哪种编程模式如何选择">3. 我该使用哪种编程模式，如何选择？&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>核心问题&lt;/th>
&lt;th>是&lt;/th>
&lt;th>否&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>你公司的业务是否有用 Java 之外的其他语言，跨语言互通的场景是不是普遍？&lt;/td>
&lt;td>Protobuf&lt;/td>
&lt;td>Java 接口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>公司里的开发人员是否熟悉 Protobuf，愿意接受 Protobuf 的额外成本吗？&lt;/td>
&lt;td>Protobuf&lt;/td>
&lt;td>Java 接口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>是否有标准 gRPC 互通诉求？&lt;/td>
&lt;td>Protobuf&lt;/td>
&lt;td>Java 接口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>是不是 Dubbo2 老用户，想平滑迁移到 triple 协议？&lt;/td>
&lt;td>Java 接口&lt;/td>
&lt;td>Protobuf&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="http-接入方式">HTTP 接入方式&lt;/h3>
&lt;p>triple 协议支持标准 HTTP 工具的直接访问，因此前端组件如浏览器、网关等接入非常边便捷，同时服务测试也变得更简单。&lt;/p>
&lt;p>当服务启动后，可以使用 cURL 命令直接访问：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>curl &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --header &lt;span style="color:#2aa198">&amp;#34;Content-Type: application/json&amp;#34;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> --data &lt;span style="color:#2aa198">&amp;#39;[&amp;#34;Dubbo&amp;#34;]&amp;#39;&lt;/span> &lt;span style="color:#cb4b16">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cb4b16">&lt;/span> http://localhost:50052/org.apache.dubbo.springboot.demo.idl.Greeter/greet/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上默认使用 &lt;code>org.apache.dubbo.springboot.demo.idl.Greeter/greet&lt;/code> 这种 HTTP 访问路径，且仅支持 post 方法，如果你想对外发布 REST 风格服务，请参考下文 REST 协议小节。&lt;/p>
&lt;h3 id="streaming-流式通信模式">Streaming 流式通信模式&lt;/h3>
&lt;h4 id="流实现原理">流实现原理&lt;/h4>
&lt;p>&lt;code>Triple&lt;/code>协议的流模式&lt;/p>
&lt;ul>
&lt;li>
&lt;p>从协议层来说，&lt;code>Triple&lt;/code> 是建立在 &lt;code>HTTP2&lt;/code> 基础上的，所以直接拥有所有 &lt;code>HTTP2&lt;/code> 的能力，故拥有了分 &lt;code>streaming&lt;/code> 和全双工的能力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>框架层来说，&lt;code>StreamObserver&lt;/code> 作为流的接口提供给用户，用于入参和出参提供流式处理。框架在收发 stream data 时进行相应的接口调用, 从而保证流的生命周期完整。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="适用场景">适用场景&lt;/h4>
&lt;p>Stream 是 Dubbo3 新提供的一种调用类型，在以下场景时建议使用流的方式:&lt;/p>
&lt;ul>
&lt;li>接口需要发送大量数据，这些数据无法被放在一个 RPC 的请求或响应中，需要分批发送，但应用层如果按照传统的多次 RPC 方式无法解决顺序和性能的问题，如果需要保证有序，则只能串行发送&lt;/li>
&lt;li>流式场景，数据需要按照发送顺序处理, 数据本身是没有确定边界的&lt;/li>
&lt;li>推送类场景，多个消息在同一个调用的上下文中被发送和处理&lt;/li>
&lt;/ul>
&lt;p>Stream 分为以下三种。&lt;/p>
&lt;h5 id="server_stream服务端流">SERVER_STREAM(服务端流)&lt;/h5>
&lt;p>A server-streaming RPC is similar to a unary RPC, except that the server returns a stream of messages in response to a client’s request. After sending all its messages, the server’s status details (status code and optional status message) and optional trailing metadata are sent to the client. This completes processing on the server side. The client completes once it has all the server’s messages.
&lt;img src="https://dubbo.apache.org/imgs/v3/migration/tri/migrate-server-stream.png" alt="SERVER_STREAM">&lt;/p>
&lt;h5 id="client_stream客户端流">CLIENT_STREAM(客户端流)&lt;/h5>
&lt;p>A client-streaming RPC is similar to a unary RPC, except that the client sends a stream of messages to the server instead of a single message. The server responds with a single message (along with its status details and optional trailing metadata), typically but not necessarily after it has received all the client’s messages.
&lt;img src="https://dubbo.apache.org/imgs/v3/migration/tri/migrate-client-stream.png" alt="CLIENT_STREAM">&lt;/p>
&lt;h5 id="bidirectional_stream双向流">BIDIRECTIONAL_STREAM(双向流)&lt;/h5>
&lt;p>In a bidirectional streaming RPC, the call is initiated by the client invoking the method and the server receiving the client metadata, method name, and deadline. The server can choose to send back its initial metadata or wait for the client to start streaming messages.&lt;/p>
&lt;p>Client- and server-side stream processing is application specific. Since the two streams are independent, the client and server can read and write messages in any order. For example, a server can wait until it has received all of a client’s messages before writing its messages, or the server and client can play “ping-pong” – the server gets a request, then sends back a response, then the client sends another request based on the response, and so on.
&lt;img src="https://dubbo.apache.org/imgs/v3/migration/tri/migrate-bi-stream.png" alt="BIDIRECTIONAL_STREAM">&lt;/p>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">流的语义保证&lt;/h4>
&lt;ul>
&lt;li>提供消息边界，可以方便地对消息单独处理&lt;/li>
&lt;li>严格有序，发送端的顺序和接收端顺序一致&lt;/li>
&lt;li>全双工，发送不需要等待&lt;/li>
&lt;li>支持取消和超时&lt;/li>
&lt;/ul>
&lt;/div>
&lt;p>关于 Streaming 的具体使用示例，请参见 【进阶学习 - 通信协议 - Streaming 流式通信】。&lt;/p>
&lt;h2 id="dubbo-协议">Dubbo 协议&lt;/h2>
&lt;h3 id="基本配置-1">基本配置&lt;/h3>
&lt;p>通过以下配置启用 dubbo 协议，默认端口为 20880，如果设置 &lt;code>port: -1&lt;/code> 则会随机选取端口（从 20880 自增，直到找到第一个可用端口）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protocol&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">name&lt;/span>: dubbo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">port&lt;/span>: &lt;span style="color:#2aa198">20880&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="服务定义方式-1">服务定义方式&lt;/h3>
&lt;p>dubbo 协议支持使用 &lt;code>Java Interface&lt;/code> 方式定义 Dubbo RPC 服务，即通过声明一个 Java 接口的方式定义服务。序列化方式可以选用 Hessian、Fastjson2、JSON、Kryo、JDK、自定义扩展等任意编码协议，默认序列化协议为 Fastjson2。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-info" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
&lt;p>自 3.2.0 版本开始，Dubbo 增加了序列化协议的自动协商机制，如果满足条件 &lt;code>两端都为 Dubbo3 特定版本 + 存在 Fastjson2 相关依赖&lt;/code>，则会自动使用 fastjson2 序列化协议，否则使用 hessian2 协议，协商对用户透明无感。&lt;/p>
&lt;p>由于 Dubbo2 默认序列化协议是 hessian2，对于部分有拦截rpc调用payload的场景，比如sidecar等对链路payload有拦截与解析，在升级过程中需留意兼容性问题。&lt;/p>
&lt;/div>
&lt;ul>
&lt;li>关于 dubbo 协议的具体使用示例请参见【进阶学习 - 通信协议】中的 &lt;a href="">dubbo 协议示例&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h3 id="http-接入方式-1">HTTP 接入方式&lt;/h3>
&lt;p>由于 dubbo 协议无法支持 http 流量直接接入，因此需要有一层网关实现前端 http 协议到后端 dubbo 协议的转换过程（&lt;code>http -&amp;gt; dubbo&lt;/code>）。Dubbo 框架提供了 &lt;code>泛化调用&lt;/code> 能力，可以让网关在无服务接口定义的情况下对后端服务发起调用。&lt;/p>
&lt;p>&lt;a href="">http -&amp;gt; dubbo 架构图&lt;/a>&lt;/p>
&lt;p>目前社区有很多开源网关产品支持 &lt;code>http -&amp;gt; dubbo&lt;/code> 的，它们大部分都提供了可视化界面配置参数映射（泛化调用），同时还支持基于 Nacos、Zookeeper 等主流注册中心的自动地址发现，具体请查看 &lt;a href="">【进阶学习 - HTTP网关接入】&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>Higress&lt;/li>
&lt;li>Pixiu&lt;/li>
&lt;li>APISIX&lt;/li>
&lt;li>Shenyu&lt;/li>
&lt;li>Tengine&lt;/li>
&lt;/ul>
&lt;h2 id="rest-协议">REST 协议&lt;/h2>
&lt;p>通过以下配置启用 rest 协议，默认端口为 8080，如果设置 &lt;code>port: -1&lt;/code> 则会随机选取端口（从 8080 自增，直到找到第一个可用端口）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protocol&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">name&lt;/span>: rest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">port&lt;/span>: &lt;span style="color:#2aa198">8080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="服务定义方式-2">服务定义方式&lt;/h3>
&lt;p>目前 rest 协议仅支持 &lt;code>Java Interface&lt;/code> 服务定义模式，相比于 dubbo 和 triple 协议，rest 场景下我们需要为 Interface 增加注解，目前支持 Spring MVC、JAX_RS 两种注解。&lt;/p>
&lt;p>Spring MVC 服务定义范例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@RequestMapping&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;/demo&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@GetMapping&lt;/span>(value &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;/hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">sayHello&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>jAX-RS 服务定义范例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@RequestMapping&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;/demo&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@GetMapping&lt;/span>(value &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;/hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">sayHello&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你记得 triple 协议原生支持 cURL 访问，即类似 &lt;code>org.apache.dubbo.springboot.demo.idl.Greeter/greet&lt;/code> 的访问模式。通过增加以上注解并将服务同时发布到 triple 协议、rest 协议，可以为 triple 服务额外增加 REST 风格访问支持。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protocols&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#268bd2">name&lt;/span>: rest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">port&lt;/span>: &lt;span style="color:#2aa198">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#268bd2">name&lt;/span>: triple
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">port&lt;/span>: &lt;span style="color:#2aa198">50051&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>关于 rest 协议的具体使用示例请参见【进阶学习 - 通信协议】中的 &lt;a href="">rest 协议示例&lt;/a>。&lt;/li>
&lt;li>关于 Dubbo 多协议支持的更多细节请参见【进阶学习 - 通信协议】中的 &lt;a href="">多协议发布&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="多协议发布">多协议发布&lt;/h2>
&lt;p>与 RPC 协议强相关的，Dubbo 支持从多个角度调整 RPC 调用时的行为，比如超时时间、线程池、连接数、负载大小、异步调用、隐式传参等，具体请查看 &lt;a href="">RPC 框架与 API&lt;/a> 中说明。&lt;/p>
&lt;p>除此之外，关于 RPC 协议还有以下相关链接可以参考：&lt;/p>
&lt;ul>
&lt;li>triple 协议规范&lt;/li>
&lt;li>dubbo 协议规范&lt;/li>
&lt;li>rest 协议规范&lt;/li>
&lt;/ul></description></item><item><title>Overview: 使用 Dubbo 开发 TCP 通信协议服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/dubbo/</guid><description>
&lt;p>本示例演示了如何开发基于 &lt;code>dubbo&lt;/code> 协议通信的服务，可在此查看 &lt;a href="">本示例的完整代码&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>新增一个示例，使用 dubbo 通信，但不包含注册中心配置&lt;/p>
&lt;/blockquote>
&lt;div class="alert alert-info" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
为了保证老版本兼容性，Dubbo 3.3.0 及之前版本的默认协议都是 &lt;code>dubbo&lt;/code>。但如果您是新用户，您正在考虑使用 Dubbo 构建一套全新的微服务系统，我们推荐您在应用中明确配置使用 &lt;code>triple&lt;/code> 协议。
&lt;/div>
&lt;h2 id="运行示例">运行示例&lt;/h2>
&lt;p>你可以跟随以下步骤，尝试运行本文档对应的示例源码。&lt;/p>
&lt;p>首先，可通过以下命令下载示例源码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone --depth&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">1&lt;/span> https://github.com/apache/dubbo-samples.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进入示例源码目录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">cd&lt;/span> dubbo-samples/extensions/protocol/dubbo/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用 maven 打包示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mvn clean install -DskipTests
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动提供者">启动提供者&lt;/h3>
&lt;p>运行以下命令启动提供者。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>java -jar ./provider/target/xxx.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="启动消费者">启动消费者&lt;/h3>
&lt;p>运行以下命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>java -jar ./consumer/target/xxx.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="源码讲解">源码讲解&lt;/h2>
&lt;h3 id="定义服务">定义服务&lt;/h3>
&lt;p>首先是服务定义，使用 &lt;code>dubbo&lt;/code> 协议时，我们首选需要通过 Java Interface 定义 Dubbo 服务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="服务提供者">服务提供者&lt;/h3>
&lt;p>其次，对于提供者一侧而言，需要提供服务的具体实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置使用 &lt;code>dubbo&lt;/code> 协议：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，是将服务发布出去：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="服务消费者">服务消费者&lt;/h3>
&lt;p>配置服务引用，如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，就可以发起对远程服务的 RPC 调用了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更多协议配置">更多协议配置&lt;/h2>
&lt;h3 id="序列化">序列化&lt;/h3>
&lt;p>消费者与提供者之间的调用使用 dubbo 协议，&lt;strong>参数使用的默认数据编码格式（即序列化）是 fastjson2&lt;/strong>，同时你也可以设置使用其他任意序列化协议，序列化不影响 dubbo 协议的正常工作（只会对编码性能有一些影响）。&lt;/p>
&lt;div class="alert alert-info" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
&lt;p>自 3.2.0 版本开始，Dubbo 增加了序列化协议的自动协商机制，如果满足条件 &lt;code>两端都为 Dubbo3 特定版本 + 存在 Fastjson2 相关依赖&lt;/code>，则会自动使用 fastjson2 序列化协议，否则使用 hessian2 协议，协商对用户透明无感。&lt;/p>
&lt;p>由于 Dubbo2 默认序列化协议是 hessian2，对于部分有拦截rpc调用payload的场景，比如sidecar等对链路payload有拦截与解析，在升级过程中需留意兼容性问题，其他用户不用担心。&lt;/p>
&lt;/div>
&lt;h3 id="共享连接">共享连接&lt;/h3>
&lt;p>对 dubbo 协议实现来说，&lt;strong>消费端机器A与提供者机器B之间默认是使用的同一个链接&lt;/strong>，即不论在 A 与 B 之间有多少服务调用，默认都始终使用同一个 tcp 连接。当然，Dubbo 框架提供了方法可以让您调整 A 与 B 之间的 tcp 连接数。&lt;/p>
&lt;p>此外，dubbo 协议还支持配置如 payload 限制、序列化、连接数、连接超时时间、心跳等，具体请参见【参考手册 - dubbo协议】。&lt;/p>
&lt;h2 id="发布rest风格服务">发布REST风格服务&lt;/h2>
&lt;h3 id="更多内容">更多内容：&lt;/h3>
&lt;ul>
&lt;li>dubbo 协议规范&lt;/li>
&lt;li>RPC 框架，如超时时间、异步调用等&lt;/li>
&lt;li>前端 HTTP 网关流量接入后端 dubbo 协议&lt;/li>
&lt;/ul></description></item><item><title>Overview: 通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/</guid><description/></item><item><title>Overview: 通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/rest/</guid><description/></item></channel></rss>